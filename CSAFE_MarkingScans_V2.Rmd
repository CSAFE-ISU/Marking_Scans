---
title: "CSAFE_MarkingScans_V2"
author: "Andrew Maloney"
date: "10/7/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

```{r}

library(tidyverse)
library(x3ptools)
library(bulletxtrctr)
library(ggplot2)
library(keras)
library(purrr)
library(svMisc)

```

```{r eval=FALSE, include=FALSE}

data_dir <- "/media/Raven/Masks/Completed/LAPD"


df <- tibble(path = list.files(path = file.path(data_dir, "Megan"), 
                               pattern = ".x3p", recursive = T, 
                               full.names = T)) %>% mutate(x3p = map(path, read_x3p))

#Scale X3p
#Keep track of min and max
#Scale 0 to 255

df_1$x3p[[1]]$surface.matrix %>% unlist() %>% as.vector() %>% summary()
x3pmin <- min(df_1$x3p[[1]]$surface.matrix, na.rm=TRUE) 
x3pmax <- max(df_1$x3p[[1]]$surface.matrix, na.rm=TRUE) #Save
df_1$x3p[[1]]$surface.matrix <- (df_1$x3p[[1]]$surface.matrix - x3pmin)/(x3pmax-x3pmin)*255
```

```{r}


f = function(x, n){
    x - 128*(1:n)
  
}


for(i in 1:nrow(df_1)){
  
  progress(i, progress.bar = TRUE)
  Sys.sleep(0.01)
  dimension_x <- dim(df_1$x3p[[i]]$surface.matrix)[1]
  dimension_y <- dim(df_1$x3p[[i]]$surface.matrix)[2]
  
  division_x <- dim(df_1$x3p[[i]]$surface.matrix)[1] / 128
  division_y <- dim(df_1$x3p[[i]]$surface.matrix)[2] / 128
  
  grid_lengths_x <- c(f(dimension_x, division_x), 0)
  grid_lengths_y <- c(f(dimension_y, division_y), 0)
  
  grid_outline <- expand.grid(grid_lengths_x, grid_lengths_y)
  
  grid_outline <- grid_outline %>% filter(Var1 >= 0 & Var2 >= 0)
  
  df_1$chop_storage[[i]] <- map2(.x = grid_outline$Var1 ,
                               .y = grid_outline$Var2 ,
                               .f = x3p_crop, x3p = df_1$x3p[[i]],
                               width = 128,
                               height = 128)
  
}

#Calculate the number of cropped images we are able to extract based on marking scan resolution
#1. Find x and y dimensions of x3p scan
#2. Calculate all x and y locations for cropping, location represents the bottom right of a crop
#3. Store each cropped image in a list of lists


```

```{r}


for(i in 1:nrow(df_2)){
  
  progress(i, progress.bar = TRUE)
  Sys.sleep(0.01)
  dimension_x <- dim(df_2$x3p[[i]]$surface.matrix)[1]
  dimension_y <- dim(df_2$x3p[[i]]$surface.matrix)[2]
  
  division_x <- dim(df_2$x3p[[i]]$surface.matrix)[1] / 128
  division_y <- dim(df_2$x3p[[i]]$surface.matrix)[2] / 128
  
  grid_lengths_x <- c(f(dimension_x, division_x), 0)
  grid_lengths_y <- c(f(dimension_y, division_y), 0)
  
  grid_outline <- expand.grid(grid_lengths_x, grid_lengths_y)
  
  grid_outline <- grid_outline %>% filter(Var1 >= 0 & Var2 >= 0)
  
  df_2$chop_storage[[i]] <- map2(.x = grid_outline$Var1 ,
                               .y = grid_outline$Var2 ,
                               .f = x3p_crop, x3p = df_2$x3p[[i]],
                               width = 128,
                               height = 128)
  
}


#Calculate the number of cropped images we are able to extract based on marking scan resolution
#1. Find x and y dimensions of x3p scan
#2. Calculate all x and y locations for cropping, location represents the bottom right of a crop
#3. Store each cropped image in a list of lists


```

```{r}



for(i in 1:nrow(df_3)){
  
  progress(i, progress.bar = TRUE)
  Sys.sleep(0.01)
  dimension_x <- dim(df_3$x3p[[i]]$surface.matrix)[1]
  dimension_y <- dim(df_3$x3p[[i]]$surface.matrix)[2]
  
  division_x <- dim(df_3$x3p[[i]]$surface.matrix)[1] / 128
  division_y <- dim(df_3$x3p[[i]]$surface.matrix)[2] / 128
  
  grid_lengths_x <- c(f(dimension_x, division_x), 0)
  grid_lengths_y <- c(f(dimension_y, division_y), 0)
  
  grid_outline <- expand.grid(grid_lengths_x, grid_lengths_y)
  
  grid_outline <- grid_outline %>% filter(Var1 >= 0 & Var2 >= 0)
  
  df_3$chop_storage[[i]] <- map2(.x = grid_outline$Var1 ,
                               .y = grid_outline$Var2 ,
                               .f = x3p_crop, x3p = df_3$x3p[[i]],
                               width = 128,
                               height = 128)
  
}

#Calculate the number of cropped images we are able to extract based on marking scan resolution
#1. Find x and y dimensions of x3p scan
#2. Calculate all x and y locations for cropping, location represents the bottom right of a crop
#3. Store each cropped image in a list of lists

```

```{r}



for(i in 1:nrow(df_4)){
  
  progress(i, progress.bar = TRUE)
  Sys.sleep(0.01)
  dimension_x <- dim(df_4$x3p[[i]]$surface.matrix)[1]
  dimension_y <- dim(df_4$x3p[[i]]$surface.matrix)[2]
  
  division_x <- dim(df_4$x3p[[i]]$surface.matrix)[1] / 128
  division_y <- dim(df_4$x3p[[i]]$surface.matrix)[2] / 128
  
  grid_lengths_x <- c(f(dimension_x, division_x), 0)
  grid_lengths_y <- c(f(dimension_y, division_y), 0)
  
  grid_outline <- expand.grid(grid_lengths_x, grid_lengths_y)
  
  grid_outline <- grid_outline %>% filter(Var1 >= 0 & Var2 >= 0)
  
  df_4$chop_storage[[i]] <- map2(.x = grid_outline$Var1 ,
                               .y = grid_outline$Var2 ,
                               .f = x3p_crop, x3p = df_4$x3p[[i]],
                               width = 128,
                               height = 128)
  
}


#Calculate the number of cropped images we are able to extract based on marking scan resolution
#1. Find x and y dimensions of x3p scan
#2. Calculate all x and y locations for cropping, location represents the bottom right of a crop
#3. Store each cropped image in a list of lists

```

```{r}

for(i in 1:nrow(df_5)){
  
  progress(i, progress.bar = TRUE)
  Sys.sleep(0.01)
  dimension_x <- dim(df_5$x3p[[i]]$surface.matrix)[1]
  dimension_y <- dim(df_5$x3p[[i]]$surface.matrix)[2]
  
  division_x <- dim(df_5$x3p[[i]]$surface.matrix)[1] / 128
  division_y <- dim(df_5$x3p[[i]]$surface.matrix)[2] / 128
  
  grid_lengths_x <- c(f(dimension_x, division_x), 0)
  grid_lengths_y <- c(f(dimension_y, division_y), 0)
  
  grid_outline <- expand.grid(grid_lengths_x, grid_lengths_y)
  
  grid_outline <- grid_outline %>% filter(Var1 >= 0 & Var2 >= 0)
  
  df_5$chop_storage[[i]] <- map2(.x = grid_outline$Var1 ,
                               .y = grid_outline$Var2 ,
                               .f = x3p_crop, x3p = df_5$x3p[[i]],
                               width = 128,
                               height = 128)
  
}

#Calculate the number of cropped images we are able to extract based on marking scan resolution
#1. Find x and y dimensions of x3p scan
#2. Calculate all x and y locations for cropping, location represents the bottom right of a crop
#3. Store each cropped image in a list of lists

```



```{r}

df_1 <- unnest(df_1, chop_storage)

for(i in 1:nrow(df_1)){
  
  df_1$labels[[i]] <- unique(pluck(df_1$chop_storage[[i]], 6)) 
  
}

df_1 <- df_1 %>% chop(c(chop_storage, labels))

#Extract the annotations for each cropped image. 
#1. Pluck can work with lists of lists, the 6 represents the location of the annotations.
#2. Store as a list of lists

#saveRDS(df_1, file="LAPD_Chopped_data_1.Rda")
```

```{r}


df_2 <- unnest(df_2, chop_storage)

for(i in 1:nrow(df_2)){
  
  df_2$labels[[i]] <- unique(pluck(df_2$chop_storage[[i]], 6)) 
  
}

df_2 <- df_2 %>% chop(c(chop_storage, labels))

#Extract the annotations for each cropped image. 
#1. Pluck can work with lists of lists, the 6 represents the location of the annotations.
#2. Store as a list of lists

#saveRDS(df_2, file="LAPD_Chopped_data_2.Rda")


```

```{r}

df_3 <- unnest(df_3, chop_storage)

for(i in 1:nrow(df_3)){
  
  df_3$labels[[i]] <- unique(pluck(df_3$chop_storage[[i]], 6)) 
  
}

df_3 <- df_3 %>% chop(c(chop_storage, labels))

#Extract the annotations for each cropped image. 
#1. Pluck can work with lists of lists, the 6 represents the location of the annotations.
#2. Store as a list of lists

#saveRDS(df_3, file="LAPD_Chopped_data_3.Rda")

```

```{r}

df_4 <- unnest(df_4, chop_storage)

for(i in 1:nrow(df_4)){
  
  df_4$labels[[i]] <- unique(pluck(df_4$chop_storage[[i]], 6)) 
  
}

df_4 <- df_4 %>% chop(c(chop_storage, labels))

#Extract the annotations for each cropped image. 
#1. Pluck can work with lists of lists, the 6 represents the location of the annotations.
#2. Store as a list of lists

#saveRDS(df_4, file="LAPD_Chopped_data_4.Rda")

```

```{r eval=FALSE, include=FALSE}

df_5 <- unnest(df_5, chop_storage)

for(i in 1:nrow(df_5)){
  
  df_5$labels[[i]] <- unique(pluck(df_5$chop_storage[[i]], 6)) 
  
}

df_5 <- df_5 %>% chop(c(chop_storage, labels))

#Extract the annotations for each cropped image. 
#1. Pluck can work with lists of lists, the 6 represents the location of the annotations.
#2. Store as a list of lists


#saveRDS(df_5, file="LAPD_Chopped_data_5.Rda")


```

```{r}

df_1 <- readRDS("LAPD_Chopped_data_1.Rda")

```


```{r}
df_1_0 <- df_1[1:10,]
df_1_1 <- df_1[11:20, ]
df_1_2 <- df_1[21:30, ]
df_1_3 <- df_1[31:40, ]
df_1_4 <- df_1[41:50, ]
df_1_5 <- df_1[51:60, ]
df_1_6 <- df_1[61:70, ]
df_1_7 <- df_1[71:80, ]
df_1_8 <- df_1[81:90, ]
df_1_9 <- df_1[91:100, ]

#Process data in small batches... because R likes to use all our memories
```



```{r}

df_1_0 <- df_1_0 %>% unnest(c(chop_storage, labels)) #Unlist

df_1_0 <- unnest(df_1_0, cols = labels) #Unlist to obtain unique annotations for each cropped scan.

#This will result in duplicate scans because some scans have 1,2,3,4,5... annotations depending on the crop.


array_1_0 = list()

for(i in 1:nrow(df_1_0)){
  
  array_1_0[[i]] <- array(c(df_1_0$chop_storage[[i]]$surface.matrix),
                     dim = c(128, 128, 1, 1))
  

}


array_1_0 <- do.call(abind, c(array_1_0, along = 0))

y_1_0 <- df_1_0$labels

save(array_1_0, y_1_0, file = "train_1_0.RData")

dim(array_1_0)


head(df_1, 5)

head(df_1_0, 5)
```

```{r}
df_1_1 <- df_1_1 %>% unnest(c(chop_storage, labels))

df_1_1 <- unnest(df_1_1, cols = labels)

array_1_1 = list()

for(i in 1:nrow(df_1_1)){
  
  array_1_1[[i]] <- array(c(df_1_1$chop_storage[[i]]$surface.matrix),
                     dim = c(128, 128, 1))
  

}


array_1_1 <- do.call(abind, c(array_1_1, along = 0))

y_1_1 <- df_1_1$labels


save(array_1_1, y_1_1, file = "train_1_1.RData")

dim(array_1_1)


```


```{r}
df_1_2 <- df_1_2 %>% unnest(c(chop_storage, labels))

df_1_2 <- unnest(df_1_2, cols = labels)

array_1_2 = list()

for(i in 1:nrow(df_1_2)){
  
  array_1_2[[i]] <- array(c(df_1_2$chop_storage[[i]]$surface.matrix),
                     dim = c(128, 128, 1))
  

}


array_1_2 <- do.call(abind, c(array_1_2, along = 0))

y_1_2 <- df_1_2$labels

save(array_1_2, y_1_2, file = "train_1_2.RData")

dim(array_1_2)


```

```{r}

df_1_3 <- df_1_3 %>% unnest(c(chop_storage, labels))

df_1_3 <- unnest(df_1_3, cols = labels)

array_1_3 = list()

for(i in 1:nrow(df_1_3)){
  
  array_1_3[[i]] <- array(c(df_1_3$chop_storage[[i]]$surface.matrix),
                     dim = c(128, 128, 1))
  

}


array_1_3 <- do.call(abind, c(array_1_3, along = 0))

y_1_3 <- df_1_3$labels


save(array_1_3, y_1_3, file = "train_1_3.RData")

dim(array_1_3)



```

```{r}




df_1_4 <- df_1_4 %>% unnest(c(chop_storage, labels))

df_1_4 <- unnest(df_1_4, cols = labels)

array_1_4 = list()

for(i in 1:nrow(df_1_4)){
  
  array_1_4[[i]] <- array(c(df_1_4$chop_storage[[i]]$surface.matrix),
                     dim = c(128, 128, 1))
  

}


array_1_4 <- do.call(abind, c(array_1_4, along = 0))

y_1_4 <- df_1_4$labels

save(array_1_4, y_1_4, file = "train_1_4.RData")

dim(array_1_4)



```

```{r}


df_1_5 <- df_1_5 %>% unnest(c(chop_storage, labels))

df_1_5 <- unnest(df_1_5, cols = labels)

array_1_5 = list()

for(i in 1:nrow(df_1_5)){
  
  array_1_5[[i]] <- array(c(df_1_5$chop_storage[[i]]$surface.matrix),
                     dim = c(128, 128, 1))
  

}


array_1_5 <- do.call(abind, c(array_1_5, along = 0))

y_1_5 <- df_1_5$labels

save(array_1_5, y_1_5, file = "train_1_5.RData")

dim(array_1_5)


```

```{r}
df_1_6 <- df_1_6 %>% unnest(c(chop_storage, labels))

df_1_6 <- unnest(df_1_6, cols = labels)

array_1_6 = list()

for(i in 1:nrow(df_1_6)){
  
  array_1_6[[i]] <- array(c(df_1_6$chop_storage[[i]]$surface.matrix),
                     dim = c(128, 128, 1))
  

}


array_1_6 <- do.call(abind, c(array_1_6, along = 0))

y_1_6 <- df_1_6$labels

save(array_1_6, y_1_6, file = "train_1_6.RData")

dim(array_1_6)

```


```{r}
df_1_7 <- df_1_7 %>% unnest(c(chop_storage, labels))

df_1_7 <- unnest(df_1_7, cols = labels)

array_1_7 = list()

for(i in 1:nrow(df_1_7)){
  
  array_1_7[[i]] <- array(c(df_1_7$chop_storage[[i]]$surface.matrix),
                     dim = c(128, 128, 1))
  

}


array_1_7 <- do.call(abind, c(array_1_7, along = 0))

y_1_7 <- df_1_7$labels

save(array_1_7, y_1_7, file = "train_1_7.RData")

dim(array_1_7)

```

```{r}
df_1_8 <- df_1_8 %>% unnest(c(chop_storage, labels))

df_1_8 <- unnest(df_1_8, cols = labels)

array_1_8 = list()

for(i in 1:nrow(df_1_8)){
  
  array_1_8[[i]] <- array(c(df_1_8$chop_storage[[i]]$surface.matrix),
                     dim = c(128, 128, 1))
  

}


array_1_8 <- do.call(abind, c(array_1_8, along = 0))

y_1_8 <- df_1_8$labels

save(array_1_8, y_1_8, file = "train_1_8.RData")

dim(array_1_8)


```

```{r}
df_1_9 <- df_1_9 %>% unnest(c(chop_storage, labels))

df_1_9 <- unnest(df_1_9, cols = labels)

array_1_9 = list()

for(i in 1:nrow(df_1_9)){
  
  array_1_9[[i]] <- array(c(df_1_9$chop_storage[[i]]$surface.matrix),
                     dim = c(128, 128, 1))
  

}


array_1_9 <- do.call(abind, c(array_1_9, along = 0))

y_1_9 <- df_1_9$labels


save(array_1_9, y_1_9, file = "train_1_9.RData")

dim(array_1_9)


```

```{r}


#input_shape <- c(3525, 128, 128, 1)

model_1 <- keras_model_sequential() %>%
  layer_conv_3d(filters = 32, kernel_size = c(3, 3, 3), padding = "same", activation = "relu", input_shape = c(128, 128, 1, 1)) %>% 
  
  #Issue (Samples hidden, ConvDim1, ConvDim2, ConvDim3?, Channels = 1)
  
  layer_max_pooling_3d(pool_size = c(2, 2, 1)) %>%
  layer_conv_3d(filters = 64, kernel_size = c(3, 3, 1), activation = "relu") %>%
  layer_max_pooling_3d(pool_size = c(2, 2, 1)) %>%
  layer_conv_3d(filters = 64, kernel_size = c(3, 3, 1), activation = "relu") %>%
  layer_max_pooling_3d(pool_size = c(2,2,1)) %>%
  layer_conv_3d(filters = 64, kernel_size = c(3,3,1), activation = "relu") %>%
  layer_max_pooling_3d(pool_size = c(2, 2, 1)) %>%
  layer_flatten() %>%
  layer_dense(units = 64, activation = "relu") %>%
  layer_dense(units = 7, activation = "softmax")
  
model_1
```

```{r}
model_1 %>% compile(
  optimizer = "rmsprop",
  loss = "categorical_crossentropy",
  metrics = c("accuracy")
)
model_1 %>% fit(
  array_1_0, y_1_0, epochs = 5, batch_size = 100
)

#reshapeData <- X_train.re

#dim(array_1_0)
```




